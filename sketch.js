const DIM = 20;const CANVAS_SIZE = 600;let tiles = [];let grid = [];let tileImages = {};const EDGE_COMPAT = {  "0": ["0", "W", "T"],  W: ["W", "0"],  T: ["T", "0"],  "1": ["1"],};const WATER_INDEX = 1;const TREE_INDEX = 2;const HOUSE_INDEX = 3;const WATER_SPAN_OPTIONS = [3, 6];const WATER_GROWTH_WEIGHT = 12;const WATER_SEED_WEIGHT = 3;let targetWaterCells = 0;let maxWaterSpan = 6;let minWaterCells = 0;let maxWaterCells = 0;const TREE_WEIGHT = 0.35;const HOUSE_WEIGHT = 0.08;class Tile {  constructor(img, edges) {    this.img = img;    this.edges = edges;    this.up = [];    this.right = [];    this.down = [];    this.left = [];  }  rotate(n) {    const w = this.img.width;    const h = this.img.height;    const newImg = createGraphics(w, h);    newImg.push();    newImg.translate(w / 2, h / 2);    newImg.rotate(HALF_PI * n);    newImg.imageMode(CENTER);    newImg.image(this.img, 0, 0);    newImg.pop();    const newEdges = [];    const len = this.edges.length;    for (let i = 0; i < len; i += 1) {      newEdges[i] = this.edges[(i - n + len) % len];    }    return new Tile(newImg, newEdges);  }  analyze(allTiles) {    for (let i = 0; i < allTiles.length; i += 1) {      const t = allTiles[i];      if (compareEdge(this.edges[0], t.edges[2])) this.up.push(i);      if (compareEdge(this.edges[1], t.edges[3])) this.right.push(i);      if (compareEdge(this.edges[2], t.edges[0])) this.down.push(i);      if (compareEdge(this.edges[3], t.edges[1])) this.left.push(i);    }  }}class Cell {  constructor(value) {    this.collapsed = false;    if (Array.isArray(value)) {      this.options = value.slice();    } else {      this.options = [];      for (let i = 0; i < value; i += 1) {        this.options.push(i);      }    }  }}function reverseEdge(edge) {  return edge.split("").reverse().join("");}function compareEdge(a, b) {  const bRev = reverseEdge(b);  if (a.length !== bRev.length) {    return false;  }  for (let i = 0; i < a.length; i += 1) {    const ok = EDGE_COMPAT[a[i]] && EDGE_COMPAT[a[i]].includes(bRev[i]);    if (!ok) {      return false;    }  }  return true;}function buildTiles() {  tiles = [];  const blank = new Tile(tileImages.grass, ["0", "0", "0", "0"]);  const water = new Tile(tileImages.water, ["W", "W", "W", "W"]);  const tree = new Tile(tileImages.tree, ["T", "T", "T", "T"]);  const house = new Tile(tileImages.house, ["T", "T", "T", "T"]);  tiles.push(blank, water, tree, house);  const tUp = new Tile(tileImages.trackUp, ["1", "1", "0", "1"]);  const tRight = new Tile(tileImages.trackRight, ["1", "1", "1", "0"]);  const tDown = new Tile(tileImages.trackDown, ["0", "1", "1", "1"]);  const tLeft = new Tile(tileImages.trackLeft, ["1", "0", "1", "1"]);  tiles.push(tUp, tRight, tDown, tLeft);  for (const t of tiles) {    t.analyze(tiles);  }}function isCollapsedWater(cell) {  return cell && cell.collapsed && cell.options[0] === WATER_INDEX;}function countCollapsedWater() {  let count = 0;  for (const cell of grid) {    if (isCollapsedWater(cell)) count += 1;  }  return count;}function currentWaterBounds() {  let minX = DIM;  let minY = DIM;  let maxX = -1;  let maxY = -1;  for (let idx = 0; idx < grid.length; idx += 1) {    if (!isCollapsedWater(grid[idx])) continue;    const x = idx % DIM;    const y = Math.floor(idx / DIM);    if (x < minX) minX = x;    if (y < minY) minY = y;    if (x > maxX) maxX = x;    if (y > maxY) maxY = y;  }  if (maxX === -1) {    return { hasWater: false, minX: 0, minY: 0, maxX: 0, maxY: 0 };  }  return { hasWater: true, minX, minY, maxX, maxY };}function wouldExceedWaterSpan(bounds, x, y) {  if (!bounds.hasWater) return false;  const minX = Math.min(bounds.minX, x);  const maxX = Math.max(bounds.maxX, x);  const minY = Math.min(bounds.minY, y);  const maxY = Math.max(bounds.maxY, y);  const spanX = maxX - minX + 1;  const spanY = maxY - minY + 1;  return spanX > maxWaterSpan || spanY > maxWaterSpan;}function waterNeighborMask(x, y) {  let mask = 0;  if (y > 0 && isCollapsedWater(grid[x + (y - 1) * DIM])) mask |= 1; /* up */ if (x < DIM - 1 && isCollapsedWater(grid[x + 1 + y * DIM])) mask |= 2; /* right */ if (y < DIM - 1 && isCollapsedWater(grid[x + (y + 1) * DIM])) mask |= 4; /* down */ if (x > 0 && isCollapsedWater(grid[x - 1 + y * DIM])) mask |= 8; /* left */ return mask;}function bitCount4(mask) {  let count = 0;  let m = mask;  while (m) {    count += m & 1;    m >>= 1;  }  return count;}function validateWaterBody() {  const water = [];  for (let idx = 0; idx < grid.length; idx += 1) {    if (isCollapsedWater(grid[idx])) water.push(idx);  }  if (water.length === 0) return false;  if (water.length < minWaterCells) return false;  if (water.length > maxWaterCells) return false;  const bounds = currentWaterBounds();  if (!bounds.hasWater) return false;  const spanX = bounds.maxX - bounds.minX + 1;  const spanY = bounds.maxY - bounds.minY + 1;  if (spanX > maxWaterSpan || spanY > maxWaterSpan) return false;  const visited = new Array(DIM * DIM).fill(false);  const queue = [water[0]];  visited[water[0]] = true;  let reached = 0;  while (queue.length) {    const idx = queue.pop();    reached += 1;    const x = idx % DIM;    const y = Math.floor(idx / DIM);    const neighbors = [];    if (y > 0) neighbors.push(idx - DIM);    if (x < DIM - 1) neighbors.push(idx + 1);    if (y < DIM - 1) neighbors.push(idx + DIM);    if (x > 0) neighbors.push(idx - 1);    for (const nIdx of neighbors) {      if (!visited[nIdx] && isCollapsedWater(grid[nIdx])) {        visited[nIdx] = true;        queue.push(nIdx);      }    }  }  return reached === water.length;}function validateNoLandIslands() {  const visited = new Array(DIM * DIM).fill(false);  const queue = [];  function enqueueIfLand(idx) {    if (idx < 0 || idx >= DIM * DIM) return;    if (visited[idx]) return;    if (isCollapsedWater(grid[idx])) return;    visited[idx] = true;    queue.push(idx);  }  /* Flood-fill all land connected to the boundary. */ for (let x = 0; x < DIM; x += 1) {    enqueueIfLand(x); /* top row */ enqueueIfLand(x + (DIM - 1) * DIM); /* bottom row */ }  for (let y = 0; y < DIM; y += 1) {    enqueueIfLand(0 + y * DIM); /* left col */ enqueueIfLand((DIM - 1) + y * DIM); /* right col */ }  while (queue.length) {    const idx = queue.pop();    const x = idx % DIM;    const y = Math.floor(idx / DIM);    if (y > 0) enqueueIfLand(idx - DIM);    if (x < DIM - 1) enqueueIfLand(idx + 1);    if (y < DIM - 1) enqueueIfLand(idx + DIM);    if (x > 0) enqueueIfLand(idx - 1);  }  /* Any land not connected to the boundary is an "island" inside water => reject. */ for (let idx = 0; idx < DIM * DIM; idx += 1) {    if (!isCollapsedWater(grid[idx]) && !visited[idx]) return false;  }  return true;}function startOver() {  maxWaterSpan = random(WATER_SPAN_OPTIONS);  maxWaterCells = maxWaterSpan * maxWaterSpan;  minWaterCells = maxWaterSpan === 3 ? 5 : 12;  targetWaterCells = Math.floor(random(minWaterCells, maxWaterCells + 1));  grid = [];  for (let i = 0; i < DIM * DIM; i += 1) {    grid[i] = new Cell(tiles.length);  }  /* Seed exactly one water source so all water stays connected (no scattered puddles). */ const seedIndex = Math.floor(random(DIM * DIM));  grid[seedIndex].collapsed = true;  grid[seedIndex].options = [WATER_INDEX];}function regenerate() {  startOver();  loop();}function keyPressed() {  if (key === "r" || key === "R") {    regenerate();  }}function preload() {  tileImages = {    grass: loadImage("grass.png"),    trackUp: loadImage("track_t_up.png"),    trackRight: loadImage("track_t_right.png"),    trackDown: loadImage("track_t_down.png"),    trackLeft: loadImage("track_t_left.png"),    water: loadImage("water.png"),    tree: loadImage("tree.png"),  };}function createHouseGraphic(w, h) {  const g = createGraphics(w, h);  g.image(tileImages.grass, 0, 0, w, h);  g.noStroke();  const baseW = w * 0.62;  const baseH = h * 0.42;  const baseX = (w - baseW) / 2;  const baseY = h * 0.48;  g.fill(214, 196, 160);  g.rect(baseX, baseY, baseW, baseH, Math.max(2, w * 0.06));  g.fill(170, 92, 70);  g.triangle(    baseX - w * 0.04,    baseY,    baseX + baseW + w * 0.04,    baseY,    w / 2,    h * 0.18,  );  const doorW = w * 0.16;  const doorH = h * 0.22;  g.fill(98, 66, 42);  g.rect(w / 2 - doorW / 2, baseY + baseH - doorH, doorW, doorH, Math.max(2, w * 0.03));  g.fill(80, 120);  const win = w * 0.12;  g.rect(baseX + w * 0.10, baseY + h * 0.08, win, win, Math.max(2, w * 0.02));  g.rect(baseX + baseW - w * 0.10 - win, baseY + h * 0.08, win, win, Math.max(2, w * 0.02));  return g;}function setup() {  const canvas = createCanvas(CANVAS_SIZE, CANVAS_SIZE);  const main = document.querySelector("main");  if (main) {    canvas.parent(main);  }  tileImages.house = createHouseGraphic(tileImages.grass.width, tileImages.grass.height);  buildTiles();  startOver();}function draw() {  background(0);  const cellW = width / DIM;  const cellH = height / DIM;  for (let j = 0; j < DIM; j += 1) {    for (let i = 0; i < DIM; i += 1) {      const index = i + j * DIM;      const cell = grid[index];      stroke(80);      noFill();      rect(i * cellW, j * cellH, cellW, cellH);      if (cell.collapsed) {        const tileIndex = cell.options[0];        image(tiles[tileIndex].img, i * cellW, j * cellH, cellW, cellH);      } else {        image(tiles[0].img, i * cellW, j * cellH, cellW, cellH);      }    }  }  let gridCopy = grid.filter((c) => !c.collapsed);  if (gridCopy.length === 0) {    if (!validateWaterBody() || !validateNoLandIslands()) {      startOver();      loop();      return;    }    noLoop();    return;  }  const waterCountBefore = countCollapsedWater();  const waterBounds = currentWaterBounds();  /* While the lake is still growing, prioritize collapsing cells adjacent to water. */ if (waterCountBefore < targetWaterCells) {    const waterFrontier = [];    for (const c of gridCopy) {      const idx = grid.indexOf(c);      const x = idx % DIM;      const y = Math.floor(idx / DIM);      if (bitCount4(waterNeighborMask(x, y)) > 0 && !wouldExceedWaterSpan(waterBounds, x, y)) {        waterFrontier.push(c);      }    }    if (waterFrontier.length > 0) {      waterFrontier.sort((a, b) => a.options.length - b.options.length);      const frontierEntropy = waterFrontier[0].options.length;      gridCopy = waterFrontier.filter((c) => c.options.length === frontierEntropy);    }  }  gridCopy.sort((a, b) => a.options.length - b.options.length);  const minEntropy = gridCopy[0].options.length;  gridCopy = gridCopy.filter((c) => c.options.length === minEntropy);  const cell = random(gridCopy);  cell.collapsed = true;  const cellIndex = grid.indexOf(cell);  const x = cellIndex % DIM;  const y = Math.floor(cellIndex / DIM);  const mask = waterNeighborMask(x, y);  const waterNeighbors = bitCount4(mask);  const wouldExceed = wouldExceedWaterSpan(waterBounds, x, y);  let pick;  if (cell.options.includes(WATER_INDEX)) {    /* No new disconnected water bodies: once water exists, only allow water next to water. */ const allowWater = waterNeighbors > 0 || waterCountBefore === 0;    const canGrow = waterCountBefore < targetWaterCells;    if (canGrow && allowWater && waterNeighbors >= 2 && !wouldExceed) {      pick = WATER_INDEX;    } else {      const weights = cell.options.map((opt) => {        if (opt === WATER_INDEX) {          if (!allowWater || wouldExceed) return 0;          if (canGrow && waterNeighbors > 0) {            const neighborBoost = (waterNeighbors + 1) * (waterNeighbors + 1);            return WATER_GROWTH_WEIGHT * neighborBoost;          }          return WATER_SEED_WEIGHT;        }        if (opt === HOUSE_INDEX) return HOUSE_WEIGHT;        if (opt === TREE_INDEX) return TREE_WEIGHT;        return 1;      });      pick = weightedRandom(cell.options, weights);    }  } else {    const weights = cell.options.map((opt) => {      if (opt === HOUSE_INDEX) return HOUSE_WEIGHT;      if (opt === TREE_INDEX) return TREE_WEIGHT;      return 1;    });    pick = weightedRandom(cell.options, weights);  }  if (pick === undefined) {    startOver();    return;  }  cell.options = [pick];  const waterCountAfter = countCollapsedWater();  const nextGrid = [];  for (let j = 0; j < DIM; j += 1) {    for (let i = 0; i < DIM; i += 1) {      const index = i + j * DIM;      const current = grid[index];      if (current.collapsed) {        nextGrid[index] = current;        continue;      }      let options = [];      for (let k = 0; k < tiles.length; k += 1) {        options.push(k);      }      if (j > 0) {        const up = grid[i + (j - 1) * DIM];        options = checkValid(options, up, "down");      }      if (i < DIM - 1) {        const right = grid[i + 1 + j * DIM];        options = checkValid(options, right, "left");      }      if (j < DIM - 1) {        const down = grid[i + (j + 1) * DIM];        options = checkValid(options, down, "up");      }      if (i > 0) {        const left = grid[i - 1 + j * DIM];        options = checkValid(options, left, "right");      }      const nMask = waterNeighborMask(i, j);      const nCount = bitCount4(nMask);      const opposite =        ((nMask & 1) && (nMask & 4)) || /* up + down */ ((nMask & 2) && (nMask & 8)); /* right + left */ const spanLimited = wouldExceedWaterSpan(waterBounds, i, j);      /* Prevent scattered water: only cells touching existing water may become water. */ if (nCount === 0 && options.includes(WATER_INDEX)) {        options = options.filter((opt) => opt !== WATER_INDEX);      }      /* Enforce maximum lake footprint (no expansion past maxWaterSpan x maxWaterSpan). */ if (spanLimited && options.includes(WATER_INDEX)) {        options = options.filter((opt) => opt !== WATER_INDEX);      }      /* Fill "gaps" inside the water body so it becomes a continuous mass. */ const shouldForceWater =        (nCount >= 3 || (nCount === 2 && opposite)) &&        (waterCountAfter < targetWaterCells || nCount >= 3 || opposite);      if (shouldForceWater && !spanLimited) {        if (options.includes(WATER_INDEX)) {          options = [WATER_INDEX];        } else {          startOver();          return;        }      }      /* Once we've hit the target size, stop expanding water outward (but still allow forced gap-filling). */ if (waterCountAfter >= targetWaterCells && nCount <= 1 && options.includes(WATER_INDEX)) {        options = options.filter((opt) => opt !== WATER_INDEX);      }      if (options.length === 0) {        startOver();        return;      }      nextGrid[index] = new Cell(options);    }  }  grid = nextGrid;}function weightedRandom(options, weights) {  let total = 0;  for (const w of weights) total += w;  if (total <= 0) return undefined;  let r = random(total);  for (let i = 0; i < options.length; i += 1) {    r -= weights[i];    if (r <= 0) return options[i];  }  return options[options.length - 1];}function checkValid(options, neighbor, dir) {  let validOptions = [];  for (const option of neighbor.options) {    validOptions = validOptions.concat(tiles[option][dir]);  }  return options.filter((opt) => validOptions.includes(opt));}function countCollapsedWaterNeighbors(x, y) {  let count = 0;  const up = y > 0 ? grid[x + (y - 1) * DIM] : null;  const right = x < DIM - 1 ? grid[x + 1 + y * DIM] : null;  const down = y < DIM - 1 ? grid[x + (y + 1) * DIM] : null;  const left = x > 0 ? grid[x - 1 + y * DIM] : null;  const neighbors = [up, right, down, left];  for (const n of neighbors) {    if (n && n.collapsed && n.options[0] === WATER_INDEX) {      count += 1;    }  }  return count;}